//! ABI-stable FFI types for `qtty` quantities.
//!
//! This module defines the `#[repr(C)]` and `#[repr(u32)]` types that form the stable C ABI
//! for cross-language interoperability. These types are designed to be safe to pass across
//! FFI boundaries.
//!
//! # ABI Stability Contract
//!
//! The discriminant values for [`UnitId`] and [`DimensionId`] are part of the ABI contract
//! and **MUST NEVER CHANGE** once assigned. New variants may be added with new discriminant
//! values, but existing values must remain stable across all versions.

use core::ffi::c_char;

// =============================================================================
// Status Codes
// =============================================================================

/// Success status code.
pub const QTTY_OK: i32 = 0;

/// Error: the provided unit ID is not recognized/valid.
pub const QTTY_ERR_UNKNOWN_UNIT: i32 = -1;

/// Error: conversion requested between incompatible dimensions.
pub const QTTY_ERR_INCOMPATIBLE_DIM: i32 = -2;

/// Error: a required output pointer was null.
pub const QTTY_ERR_NULL_OUT: i32 = -3;

/// Error: the provided value is invalid (reserved for future use).
pub const QTTY_ERR_INVALID_VALUE: i32 = -4;

// =============================================================================
// Dimension Identifiers
// =============================================================================

/// Dimension identifier for FFI.
///
/// Represents the physical dimension of a quantity. All discriminant values are
/// explicitly assigned and are part of the ABI contract.
///
/// # ABI Contract
///
/// **Discriminant values must never change.** New dimensions may be added with
/// new explicit discriminant values.
#[repr(u32)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum DimensionId {
    /// Length dimension (e.g., meters, kilometers).
    Length = 1,
    /// Time dimension (e.g., seconds, hours).
    Time = 2,
    /// Angle dimension (e.g., radians, degrees).
    Angle = 3,
    /// Mass dimension (e.g., grams, kilograms).
    Mass = 4,
    /// Power dimension (e.g., watts, kilowatts).
    Power = 5,
}

// =============================================================================
// Unit Identifiers
// =============================================================================

// =============================================================================
// Unit Identifiers
// =============================================================================

// The UnitId enum is generated by build.rs from qtty-core unit definitions.
// All discriminant values are explicitly assigned and are part of the ABI contract.
// Units are grouped by dimension with reserved ranges:
// - Length units: 100-199, Time units: 200-299, Angle units: 300-399
// - Mass units: 400-499, Power units: 500-599
include!(concat!(env!("OUT_DIR"), "/unit_id_enum.rs"));

impl UnitId {
    /// Returns the unit name as a static NUL-terminated C string.
    ///
    /// This is safe to call from C code and returns a pointer to static memory.
    #[inline]
    pub const fn name_cstr(&self) -> *const c_char {
        include!(concat!(env!("OUT_DIR"), "/unit_names_cstr.rs"))
    }

    /// Returns the unit name as a Rust string slice.
    #[inline]
    pub const fn name(&self) -> &'static str {
        include!(concat!(env!("OUT_DIR"), "/unit_names.rs"))
    }

    /// Attempts to create a `UnitId` from a raw `u32` discriminant value.
    ///
    /// Returns `None` if the value does not correspond to a valid unit.
    #[inline]
    pub const fn from_u32(value: u32) -> Option<Self> {
        include!(concat!(env!("OUT_DIR"), "/unit_from_u32.rs"))
    }
}

// =============================================================================
// Quantity Carrier Type
// =============================================================================

/// A POD quantity carrier type suitable for FFI.
///
/// This struct represents a physical quantity as a value paired with its unit.
/// It is `#[repr(C)]` to ensure a stable, predictable memory layout across
/// language boundaries.
///
/// # Memory Layout
///
/// - `value`: 8 bytes (f64)
/// - `unit`: 4 bytes (u32 via UnitId)
/// - Padding: 4 bytes (for alignment)
/// - Total: 16 bytes on most platforms
///
/// # Example
///
/// ```rust
/// use qtty_ffi::{QttyQuantity, UnitId};
///
/// let q = QttyQuantity {
///     value: 1000.0,
///     unit: UnitId::Meter,
/// };
/// ```
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct QttyQuantity {
    /// The numeric value of the quantity.
    pub value: f64,
    /// The unit identifier for this quantity.
    pub unit: UnitId,
}

impl QttyQuantity {
    /// Creates a new quantity with the given value and unit.
    #[inline]
    pub const fn new(value: f64, unit: UnitId) -> Self {
        Self { value, unit }
    }
}

impl Default for QttyQuantity {
    fn default() -> Self {
        Self {
            value: 0.0,
            unit: UnitId::Meter,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn unit_id_discriminants_are_stable() {
        // These values are part of the ABI contract and must never change
        assert_eq!(UnitId::Meter as u32, 10011);       // Length, SI, #11
        assert_eq!(UnitId::Kilometer as u32, 10014);   // Length, SI, #14
        assert_eq!(UnitId::Second as u32, 20008);      // Time, SI, #8
        assert_eq!(UnitId::Minute as u32, 21000);      // Time, Common, #0
        assert_eq!(UnitId::Hour as u32, 21001);        // Time, Common, #1
        assert_eq!(UnitId::Day as u32, 21002);         // Time, Common, #2
        assert_eq!(UnitId::Radian as u32, 30001);      // Angle, Radian, #1
        assert_eq!(UnitId::Degree as u32, 31004);      // Angle, Degree, #4
    }

    #[test]
    fn dimension_id_discriminants_are_stable() {
        // These values are part of the ABI contract and must never change
        assert_eq!(DimensionId::Length as u32, 1);
        assert_eq!(DimensionId::Time as u32, 2);
        assert_eq!(DimensionId::Angle as u32, 3);
    }

    #[test]
    fn unit_id_from_u32_roundtrips() {
        for unit in [
            UnitId::Meter,
            UnitId::Kilometer,
            UnitId::Second,
            UnitId::Minute,
            UnitId::Hour,
            UnitId::Day,
            UnitId::Radian,
            UnitId::Degree,
        ] {
            let value = unit as u32;
            assert_eq!(UnitId::from_u32(value), Some(unit));
        }
    }

    #[test]
    fn unit_id_from_u32_rejects_invalid() {
        assert_eq!(UnitId::from_u32(0), None);
        assert_eq!(UnitId::from_u32(99), None);
        assert_eq!(UnitId::from_u32(600), None);
        assert_eq!(UnitId::from_u32(999), None);
    }

    #[test]
    fn unit_names_are_not_empty() {
        for unit in [
            UnitId::Meter,
            UnitId::Kilometer,
            UnitId::Second,
            UnitId::Minute,
            UnitId::Hour,
            UnitId::Day,
            UnitId::Radian,
            UnitId::Degree,
        ] {
            assert!(!unit.name().is_empty());
        }
    }
}
